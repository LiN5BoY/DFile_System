
# 哈希表面试问题总结

## 基本概念

### 1. 哈希表的定义是什么？
哈希表是一种基于键值对的数据结构，通过哈希函数将键映射到数组中的一个位置（称为桶或槽），以便快速进行插入、删除和查找操作。

### 2. 哈希函数的作用是什么？
哈希函数的主要作用是将输入的键映射为哈希表的索引值，从而将数据均匀分布到哈希表的存储空间中，减少冲突的发生。

---

## 操作

### 1. 如何在哈希表中插入、删除和查找元素？
- **插入**：
  - 使用哈希函数计算键的哈希值，得到索引。
  - 如果索引位置为空，则直接插入；否则，按冲突解决策略处理。
- **删除**：
  - 根据键计算索引，找到对应的元素。
  - 将元素标记为已删除，或者更新链表/开放地址中的状态。
- **查找**：
  - 使用哈希函数计算索引，检查对应位置是否存在目标键。

### 2. 这些操作的时间复杂度是多少？
- **平均情况**：O(1)
- **最坏情况**：O(n)（当发生大量冲突时，例如所有键都被映射到同一个槽中）

---

## 解决冲突

### 1. 哈希表中常见的冲突解决方法有哪些？
- **链式地址法**：
  - 在每个哈希槽中维护一个链表，冲突的元素以链表节点追加。
- **开放地址法**：
  - 当发生冲突时，按照一定的规则（如线性探测、二次探测或双重哈希）寻找下一个可用槽。

### 2. 如何选择合适的哈希函数以减少冲突？
- **简单性**：哈希函数应易于计算。
- **均匀性**：能将输入分布均匀映射到哈希表中。
- **独特性**：减少不同键映射到相同索引的概率。
- **示例**：
  - 常用哈希函数：`key % table_size`。
  - 对于字符串键，可使用多项式哈希函数：`hash = s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]`。

---

## 设计问题

### 1. 设计一个支持插入、删除和查找的哈希表
#### 基本实现步骤：
1. 初始化一个固定大小的数组（哈希表）。
2. 使用哈希函数将键映射到数组索引。
3. 采用冲突解决方法（如链式地址法）。
4. 提供插入、删除和查找操作的接口。

#### 示例代码：
```cpp
#include <iostream>
#include <vector>
#include <list>

class HashTable {
private:
    std::vector<std::list<std::pair<int, int>>> table;
    int size;

    int hashFunction(int key) {
        return key % size;
    }

public:
    HashTable(int size) : size(size) {
        table.resize(size);
    }

    void insert(int key, int value) {
        int index = hashFunction(key);
        for (auto &pair : table[index]) {
            if (pair.first == key) {
                pair.second = value;
                return;
            }
        }
        table[index].emplace_back(key, value);
    }

    void remove(int key) {
        int index = hashFunction(key);
        table[index].remove_if([key](const std::pair<int, int> &pair) { return pair.first == key; });
    }

    int get(int key) {
        int index = hashFunction(key);
        for (const auto &pair : table[index]) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        return -1; // Key not found
    }
};
```

---

### 2. 如何处理动态扩展和收缩？
- **动态扩展**：
  - 当负载因子超过某个阈值（如 0.75）时，扩大哈希表的大小（通常是两倍）。
  - 将旧哈希表中的所有元素重新哈希到新表中。
- **动态收缩**：
  - 当负载因子低于某个阈值（如 0.25）时，缩小哈希表的大小（通常是减半）。
  - 同样需要重新哈希所有元素。

---

## 应用场景

### 1. 哈希表的典型应用场景有哪些？
- **快速查找**：如缓存（LRU Cache）、散列索引。
- **数据去重**：检测重复元素。
- **计数统计**：如统计字符出现次数。
- **关联存储**：如实现字典或映射。

### 2. 在什么情况下不适合使用哈希表？
- **需要排序的数据**：哈希表无法维护数据的顺序。
- **小规模数据集**：数组或链表可能更简单高效。
- **对内存敏感的场景**：哈希表可能需要额外的空间来处理冲突。

---

## 性能考虑

### 1. 如何评估哈希表的性能？
- **查找时间复杂度**：评估插入、查找、删除的平均和最坏时间复杂度。
- **冲突率**：观察不同哈希函数下的冲突发生频率。
- **扩展性能**：评估哈希表动态扩展时的重新哈希成本。

### 2. 负载因子（load factor）是什么，如何影响哈希表的性能？
- **定义**：负载因子是哈希表中元素数量与槽数量的比值。
  ```plaintext
  Load Factor = Number of Elements / Number of Slots
  ```
- **影响**：
  - **较低的负载因子**：减少冲突，提升性能，但浪费空间。
  - **较高的负载因子**：节省空间，但冲突增多，性能下降。
- **动态调整**：通过动态扩展/收缩，保持负载因子在合理范围内（如 0.5 - 0.75）。

---

## 补充可能性问题

1. **如何避免最坏情况下的性能（O(n)）？**
   - 使用高质量的哈希函数，减少冲突。
   - 采用动态扩展机制，避免过高的负载因子。
   - 使用链式地址法时，链表可替换为红黑树等高级数据结构。

2. **如何实现线程安全的哈希表？**
   - 使用互斥锁（如 `std::mutex`）保护对哈希表的访问。
   - 使用分段锁（Segmented Locking）提高并发性能。

3. **如何在分布式环境中实现哈希表？**
   - 使用一致性哈希算法（Consistent Hashing）实现负载均衡。
   - 在分布式系统中，哈希表可以用于分布式缓存（如 Redis）。

4. **哈希表与其他数据结构的对比**：
   - 哈希表 vs 数组：数组支持随机访问，但插入和删除效率低。
   - 哈希表 vs 链表：链表适合小数据集和顺序操作。
   - 哈希表 vs 二叉搜索树：树支持有序数据，但哈希表平均性能更优。

5. **如何处理重复键值对？**
   - 允许覆盖：直接更新值。
   - 不允许覆盖：维护一个值列表（如 `std::unordered_multimap`）。

---
